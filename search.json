[{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Peter Meilstrup. Maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Meilstrup P (2022). nseval: Tools Lazy Non-Standard Evaluation. R package version 0.4.2.","code":"@Manual{,   title = {nseval: Tools for Lazy and Non-Standard Evaluation},   author = {Peter Meilstrup},   year = {2022},   note = {R package version 0.4.2}, }"},{"path":"/index.html","id":"nseval","dir":"","previous_headings":"","what":"Tools for Lazy and Non-Standard Evaluation","title":"Tools for Lazy and Non-Standard Evaluation","text":"nseval missing API non-standard evaluation metaprogramming R.","code":""},{"path":"/index.html","id":"who-nseval-is-for","dir":"","previous_headings":"","what":"Who NSEval is for","title":"Tools for Lazy and Non-Standard Evaluation","text":"nseval might : ’ve befuddled trying get desired results using functions like substitute, eval, parent.frame(), .call, match.call, cases non-standard evauation; ’re befuddled trying interface people’s code uses functions, need way work around ; want better understand “goes ” “hood” R running.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Tools for Lazy and Non-Standard Evaluation","text":"NSEval CRAN, install latest release : install development branch:","code":"install.packages(\"nseval\") install.packages(\"devtools\") devtools::install_github(\"crowding/nseval\")"},{"path":"/index.html","id":"what-nseval-does","dir":"","previous_headings":"Installation","what":"What nseval does","title":"Tools for Lazy and Non-Standard Evaluation","text":"nseval introduces two S3 classes: quotation, dots, mirror R’s promises ..., respectively. Unlike counterparts, ordinary data objects, can assigned variables manipulated without triggering evaluation. quotation combines R expression environment. also forced quotations, pair expression value. dots named list quotations. set consistently-named accessors constructors capturing, constructing, manipulating objects.","code":""},{"path":"/index.html","id":"quick-intro--transitioning-from-base-r-to-nseval","dir":"","previous_headings":"","what":"Quick intro / transitioning from base R to NSEval","title":"Tools for Lazy and Non-Standard Evaluation","text":"quo. captures environment along text argument. Similarly, dots() captures multiple arguments, analagously alist. arg(x), captures argument’s environment along text. dots(...), capture ... unevaluated, including original environments, arg_list(x, y, (...)), include arguments well. get_call, preserves environment attached argument. , allows different arguments passed different environments. arg_env, gives environment attached argument (recognizing can different different arguments!) caller, returns calling environment, like parent.frame often , avoids latter’s difficulties lazy evaluation closures; caller rather throw error return incorrect result.","code":""},{"path":"/index.html","id":"why-nseval-is-needed","dir":"","previous_headings":"Quick intro / transitioning from base R to NSEval","what":"Why nseval is needed","title":"Tools for Lazy and Non-Standard Evaluation","text":"R, S, S metaprogramming facilities, exposed functions like parent.frame, substitute, match.call, .call, quote, alist, eval, . R duplicated API. S lexical scoping, closures, notion environment, whereas R things. S, lazily evaluated arguments evaluated simply stepping one step call stack evaluating context. case R, environments can come different sources via ..., drop stack, re-activated via closures (situations happen frequently enough everyday code). R coping metaprogramming API designed R’s capabilities mind. S interface sufficient model R behavior, end consequences : match.call() loses information argument scopes, normally occurring function calls often can’t captured reproducible form; .call can’t reproduce many situations occur normal evaluation R; parent.frame() tells something almost entirely unlike actually need know situations; ’s difficult wrap extend nonstandard-evaluating functions; ’s difficult use nonstandard-evaluating function argument higher order function; mixture metaprogramming ... rapidly turns painful; . result, R functions use S metaprogramming API often end unintended behaviors don’t “fit” R: lose track variable scope, suffer name collisions, difficult compose, etc. good news can simply replace uses match.call, parent.frame, .call equivalents nseval, may fewer kinds problems.","code":""},{"path":"/index.html","id":"what-nseval-doesnt-do","dir":"","previous_headings":"Quick intro / transitioning from base R to NSEval","what":"What nseval doesn’t do","title":"Tools for Lazy and Non-Standard Evaluation","text":"nseval doesn’t implement quasiquotation hygeinic macros code coverage DSLs interactive debugging. intended solid foundation build kinds tools ! Watch space. nseval doesn’t introduce fancy syntax – nonstandard evaluation interface name lookup quoting, standard-evaluating equivalents always also present. nseval doesn’t try remake R’s base library, just parts calls lazy evaluation. nseval install dependencies play well base R ’verse.","code":""},{"path":"/index.html","id":"similar-packages","dir":"","previous_headings":"","what":"Similar packages","title":"Tools for Lazy and Non-Standard Evaluation","text":"packages tread similar ground: rlang lazyeval pryr vadr, package carved rewritten .","code":""},{"path":"/index.html","id":"further-reading","dir":"","previous_headings":"","what":"Further reading","title":"Tools for Lazy and Non-Standard Evaluation","text":"turns R’s implementation lazy evaluation via “promise” objects amount recreation fexprs. topic work fexprs, particularly combination lexical scope environments, John Shutt’s 2010 PhD thesis helpful.","code":""},{"path":"/reference/arg.html","id":null,"dir":"Reference","previous_headings":"","what":"Capture lazy variables as quotations. — arg","title":"Capture lazy variables as quotations. — arg","text":"arg(x) looks calling environment binding x, taken literally, returns quotation. arg(x) equivalent unwrap(quo(x)). arg_ evaluates first element normally; arg(x, e) equivalent arg_(quote(x), e). arg_list looks multiple variables, returns dots object.  arg_list(x, y) equivalent unwrap(dots(x=x, y=y)). requested variables bound, error raised. arg_list_ normally evaluating version arg_list; arg_list(x, y) equivalent arg_list_(alist(x, y), environment()). set_arg set_arg_ create bindings quotations. replace base function delayedAssign.","code":""},{"path":"/reference/arg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Capture lazy variables as quotations. — arg","text":"","code":"arg(sym, env = arg_env_(quote(sym), environment()))  arg_(sym, env = arg_env(sym, environment()))  arg_list(...)  arg_list_(syms, envs)  set_arg(dst, src)  set_arg_(dst, src)"},{"path":"/reference/arg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Capture lazy variables as quotations. — arg","text":"sym name look . arg literal name, evaluated. arg_ evaluate symbol character. env environment look . default, environment sym passed. ... Bare names (forced). Arguments may named; names determine names output list. arguments named, names given used. syms character vector list names. envs environment, list environments, look bindings . dst name; set_arg quoted literally; set_arg_ quotation. src quotation (something can converted quotation, like formula).","code":""},{"path":"/reference/arg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Capture lazy variables as quotations. — arg","text":"arg returns quotation object. args returns dots object. arg_list returns dots object.","code":""},{"path":"/reference/arg.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Capture lazy variables as quotations. — arg","text":"use literal character value, arg_(\"x\", environment()), MUST also give environment parameter. reason R discard scope information code literals byte-compiled code; arg_(\"x\") called compiled code, default value env found emptyenv(). Beware writing arg_list(, b, ...) probably want. R unwraps ... invoking arg_list, ends double-unwrapping .... capture ... alongside named arguments can use syntax arg_list(x, y, (...)) (equivalent c(arg_list(x, y), dots(...))). can also use get_call() extract function inputs active function.","code":""},{"path":[]},{"path":"/reference/as.dots.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert items into quotations or dots. — as.dots","title":"Convert items into quotations or dots. — as.dots","text":".dots generic function converting data dots. .dots.environment synonym env2dots.","code":""},{"path":"/reference/as.dots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert items into quotations or dots. — as.dots","text":"","code":"as.dots(x)  # S3 method for dots as.dots(x)  # S3 method for quotation as.dots(x)  # S3 method for list as.dots(x)  # S3 method for environment as.dots(x)  # S3 method for lazy_dots as.dots(x)  # S3 method for default as.dots(x)"},{"path":"/reference/as.dots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert items into quotations or dots. — as.dots","text":"x vector list.","code":""},{"path":"/reference/as.dots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert items into quotations or dots. — as.dots","text":"object class ....","code":""},{"path":[]},{"path":"/reference/caller.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the caller of a given environment. — caller","title":"Find the caller of a given environment. — caller","text":"Given environment currently stack, caller determines calling environment.","code":""},{"path":"/reference/caller.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the caller of a given environment. — caller","text":"","code":"caller(   env = caller(environment()),   ifnotfound = stop(\"caller: environment not found on stack\") )"},{"path":"/reference/caller.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the caller of a given environment. — caller","text":"env environment whose caller find. default caller's caller; , caller() return value caller(environment()).) ifnotfound return case caller determined. default error raised.","code":""},{"path":"/reference/caller.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the caller of a given environment. — caller","text":"environment called env . environment determined, ifnotfound returned.","code":""},{"path":"/reference/caller.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find the caller of a given environment. — caller","text":"example, code: environment called Y created calling F(), call occurs environment called X. case X calling environment Y, F() returns environment X(). caller intended replacement parent.frame, returns next environment calling stack -- sometimes value, differs situations, lazy evaluation re-activates environment. parent.frame() can return different things depending order arguments evaluated, without warning. caller default throw error caller determined. addition, caller tries right thing environment instantiated means .call, eval rather ordinary function call.","code":"X <- environment() F <- function() {   Y <- environment()   caller(Y) } F()"},{"path":"/reference/caller.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find the caller of a given environment. — caller","text":"","code":"E <- environment() F <- function() {  Y <- environment()  caller(Y) } identical(F(), E) ## TRUE #> [1] TRUE"},{"path":"/reference/compat.html","id":null,"dir":"Reference","previous_headings":"","what":"Compatibility conversions. — as.lazy_dots","title":"Compatibility conversions. — as.lazy_dots","text":"Convert quotations dot lists representations used packages.","code":""},{"path":"/reference/compat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compatibility conversions. — as.lazy_dots","text":"","code":"as.lazy_dots(x, env)  # S3 method for dots as.lazy_dots(x, env = \"ignored\")"},{"path":"/reference/compat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compatibility conversions. — as.lazy_dots","text":"x dots object. env See lazyeval::.lazy_dots.","code":""},{"path":"/reference/compat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compatibility conversions. — as.lazy_dots","text":".lazy_dots returns lazyeval::lazy_dots object.","code":""},{"path":"/reference/do.html","id":null,"dir":"Reference","previous_headings":"","what":"Making function calls, with full control of argument scope. — do","title":"Making function calls, with full control of argument scope. — do","text":"functions do_ construct invoke function call. combination dots quotation objects allow control scope function call arguments independently.","code":""},{"path":"/reference/do.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Making function calls, with full control of argument scope. — do","text":"","code":"do(...)  do_(...)"},{"path":"/reference/do.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Making function calls, with full control of argument scope. — do","text":"... function call list(s) arguments pass. quotation dots objects, except first argument quoted literally.","code":""},{"path":"/reference/do.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Making function calls, with full control of argument scope. — do","text":"return value call.","code":""},{"path":"/reference/do.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Making function calls, with full control of argument scope. — do","text":"do_ arguments quotation dots objects, convertible using .quo(). concatenated together c.dots form call list (dots object). first argument quoted literally, rest arguments evaluated way do_. head, first element call list, represents function, evaluate function object. rest call list used function's arguments. quotation used first element, call evaluated environment given quotation. means calls caller() (parent.frame()) within function return environment. intended replacement base function .call. instance two lines similar effect: :","code":"do.call(\"complex\", list(imaginary = 1:3)) do(complex, dots(imaginary = 1:3)) do.call(\"f\", list(as.name(\"A\")), envir = env) do_(quo(f, env), quo(A, env)): do_(dots_(list(as.name(\"f\"), as.name(\"A\")), env)) do_(dots_(alist(f, A), env))"},{"path":"/reference/do.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Making function calls, with full control of argument scope. — do","text":"environment call head differs arguments, may make temporary binding ... pass arguments. cause primitive functions, like ( <-, ), fail error like \"'...' used incorrect context,\" primitives understand unpack .... avoid use ..., ensure args environment call head, forced. specific case calling <-, can use set_ make assignments.","code":""},{"path":[]},{"path":"/reference/dots.html","id":null,"dir":"Reference","previous_headings":"","what":"Dots objects: lists of quotations. — dots","title":"Dots objects: lists of quotations. — dots","text":"d <- dots(= one, b = two) captures arguments, unevaluated, dots object (named list quotations). .data.frame.dots transforms contents dots object data frame one row per quotation, columns: name: character, expr: expression, env: environment object NULL forced, value: NULL value forced. forced_dots(...) forces arguments constructs dots object forced quotations. forced_dots_(values) creates dots object list values","code":""},{"path":"/reference/dots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dots objects: lists of quotations. — dots","text":"","code":"dots(...)  dots_(exprs, envs)  exprs(d)  # S3 method for dots exprs(d)  exprs(d) <- value  # S3 method for dots exprs(d) <- value  envs(d)  # S3 method for dots envs(d)  envs(d) <- value  # S3 method for dots [(x, ..., drop = FALSE)  # S3 method for dots [(x, ...) <- value  # S3 method for dots c(...)  # S3 method for quotation c(...)  # S3 method for dots as.data.frame(x, row.names = NULL, ...)  forced_dots(...)  forced_dots_(values)"},{"path":"/reference/dots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dots objects: lists of quotations. — dots","text":"... number arguments. exprs expression list expressions. envs environment list environments. d dots object. value replacement value list values. x dots object. drop See Extract. row.names given, uses make.unique(x$name) values list; element used data.","code":""},{"path":"/reference/dots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dots objects: lists of quotations. — dots","text":"dots(...) constructs list class 'dots', element quotation. dots_(exprs, envs) constructs dots object given lists expressions environments. (construct dots object quotation objects, use c().) exprs(d) extracts list expressions dots object. mutator exprs(d) <- value returns new dots object new expressions. envs(d) extracts list environments dots object. envs(d) returns named list environments. envs(d) <- value returns updated dots object environments replaced new value(s). .data.frame.dots returns data frame.","code":""},{"path":"/reference/dots.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dots objects: lists of quotations. — dots","text":"Objects class \"dots\" mirror R's special variable .... Unlike ..., dots : immutable (evaluating change ), first-class (can give name, just ...), data (R interpreter treates literal data rather triggering argument splicing). d <- dots(...) used capture contents ... without triggering evaluation. improves .list(substitute(...())) capturing environment argument along expressions. (can also use get_dots().)","code":""},{"path":"/reference/dots.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Dots objects: lists of quotations. — dots","text":"columns class \"oneline\" better printing.","code":""},{"path":"/reference/dots.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dots objects: lists of quotations. — dots","text":"","code":"named.list <- function(...) {  # Collect only named arguments, ignoring unnamed arguments.  d <- dots(...)  do(list, d[names(d) != \"\"]) }  named.list(a=1, b=2*2, stop(\"this is not evaluated\")) #> $a #> [1] 1 #>  #> $b #> [1] 4 #>"},{"path":"/reference/dots2env.html","id":null,"dir":"Reference","previous_headings":"","what":"Make or update an environment with bindings from a dots list. — dots2env","title":"Make or update an environment with bindings from a dots list. — dots2env","text":"named entries dots object bound variables. Unnamed entries appended existing value ... order appear.","code":""},{"path":"/reference/dots2env.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make or update an environment with bindings from a dots list. — dots2env","text":"","code":"dots2env(   x,   env = new.env(hash = hash, parent = parent, size = size),   names = NULL,   use_dots = TRUE,   append = TRUE,   hash = (length(dots) > 100),   size = max(29L, length(dots)),   parent = emptyenv() )  # S3 method for dots as.environment(x)"},{"path":"/reference/dots2env.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make or update an environment with bindings from a dots list. — dots2env","text":"x dots object names. env Specify environment object populate return. default new environment created. names variables populate environment. NULL given, use names present dotlist.  name given match names dots object, error raised. use_dots Whether bind unnamed unmatched items .... FALSE, items discarded. TRUE, bound ... environment. items duplicate names, earlier ones used rest placed \"...\". append TRUE, unmatched unnamed items appended existing value '...'. FALSE, existing binding ... cleared. (Neither happens use_dots FALSE.) hash env NULL, argument passed new.env. size env NULL, argument paseed new.env. parent env NULL, argument paseed new.env.","code":""},{"path":"/reference/dots2env.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make or update an environment with bindings from a dots list. — dots2env","text":"environment object.","code":""},{"path":[]},{"path":"/reference/env2dots.html","id":null,"dir":"Reference","previous_headings":"","what":"Copy bindings from an environment into a dots object, or vice versa. — env2dots","title":"Copy bindings from an environment into a dots object, or vice versa. — env2dots","text":"env2dots copies bindings environment (parents) new dots object. Bindings promises captured without forcing. Bindings promises rendered forced quotations. output guaranteed order.","code":""},{"path":"/reference/env2dots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Copy bindings from an environment into a dots object, or vice versa. — env2dots","text":"","code":"env2dots(   env = caller(environment()),   names = ls(envir = env, all.names = TRUE),   include_missing = TRUE,   expand_dots = TRUE )"},{"path":"/reference/env2dots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Copy bindings from an environment into a dots object, or vice versa. — env2dots","text":"env environment. names names extract environment. default extracts bindings present env, enclosing environments. include_missing Whether include missing bindings. expand_dots Whether include contents ....","code":""},{"path":"/reference/env2dots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Copy bindings from an environment into a dots object, or vice versa. — env2dots","text":"dots object.","code":""},{"path":"/reference/forced.html","id":null,"dir":"Reference","previous_headings":"","what":"Forcing and forcedness of arguments and quotations. — forced","title":"Forcing and forcedness of arguments and quotations. — forced","text":"two kinds quotations: forced unforced. Unforced quotations expression environment; forced quotations expression value. forced(q) tests whether quotation forced. forced(d) dots object tests whether element forced, returns logical vector. force_(x) converts unforced quotation dots object forced one, evaluating . value(x) values(...) returns value quotation dots, forcing necessary.","code":""},{"path":"/reference/forced.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Forcing and forcedness of arguments and quotations. — forced","text":"","code":"forced(x)  # S3 method for quotation forced(x, ...)  # S3 method for dots forced(x)  # S3 method for default forced(x)  force_(x, ...)  # S3 method for quotation force_(x, eval = base::eval, ...)  # S3 method for dots force_(x, ...)  value(x, ...)  # S3 method for quotation value(x, mode = \"any\", ...)  # S3 method for dots value(x, ...)  values(x)  # S3 method for dots values(x)"},{"path":"/reference/forced.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Forcing and forcedness of arguments and quotations. — forced","text":"x quotation dots object. ... Options used methods eval evaluation function use. mode Whether force \"\" mode \"function\" mode (see locate).","code":""},{"path":"/reference/forced.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Forcing and forcedness of arguments and quotations. — forced","text":"forced(x) returns logical. value(x) returns result forcing quotation. values returns list.","code":""},{"path":[]},{"path":"/reference/format.html","id":null,"dir":"Reference","previous_headings":"","what":"Formatting methods for dots and quotations. — format.dots","title":"Formatting methods for dots and quotations. — format.dots","text":"format.dots constructs string representation dots object. format.quotation constructs string representation quotation object. format.oneline formats vector list item displayed one line. similar format.AsIs tries harder language objects. \"oneline\" class used .data.frame.dots.","code":""},{"path":"/reference/format.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Formatting methods for dots and quotations. — format.dots","text":"","code":"# S3 method for dots format(   x,   compact = FALSE,   show.environments = !compact,   show.expressions = !compact,   width = 36,   ... )  # S3 method for quotation format(   x,   compact = FALSE,   show.environments = !compact,   show.expressions = !compact,   width = 36,   ... )  # S3 method for oneline format(x, max.width = 50, width = max.width, ...)  # S3 method for dots print(x, ...)  # S3 method for quotation print(x, ...)"},{"path":"/reference/format.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Formatting methods for dots and quotations. — format.dots","text":"x object. compact Implies show.environments=FALSE show.expressions=FALSE. show.environments Whether show environments unforced quotations. show.expressions Whether show expressions forced quotations. width See base::format. ... parameters passed along base::format. max.width See base::format.","code":""},{"path":"/reference/function_.html","id":null,"dir":"Reference","previous_headings":"","what":"Explicitly create closures. — function_","title":"Explicitly create closures. — function_","text":"function_ normally-evaluating version function, creates closures. closure object three components: argument list, body expression, enclosing environment. arglist() helper produces named list missing_values given character vector names.","code":""},{"path":"/reference/function_.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Explicitly create closures. — function_","text":"","code":"function_(args, body, env = arg_env(args, environment()))  arglist(names, fill = missing_value())"},{"path":"/reference/function_.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Explicitly create closures. — function_","text":"args argument list new function. NULL accepted make function arguments. Arguments specified named list; list names become argument names, list values become default expressions. value missing_value() indicates default. alist arglist useful making argument lists. body expression body function. env enclosing environment new function. names character vector. fill expression (default missing)","code":""},{"path":"/reference/function_.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Explicitly create closures. — function_","text":"closure.","code":""},{"path":[]},{"path":"/reference/function_.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Explicitly create closures. — function_","text":"","code":"f1 <- function(x, y = x) { x + y } f2 <- function_(alist(x = , y = x),                 quote( { x + y } ),                 environment()) identical(f1, f2) # TRUE #> [1] TRUE  # `fn` makes a compact way to write functions; # `fn(x+y)` is equivalent to `function(x, y) x+y` fn <- function(exp) {   exp_ <- arg(exp)   nn <- arglist(all.names(expr(exp_), functions=FALSE))   function_(nn, expr(exp_), env(exp_)) }  fn(x^2) #> function (x)  #> x^2 #> <environment: 0x555e768948d8> fn(x+y) #> function (x, y)  #> x + y #> <environment: 0x555e768948d8>"},{"path":"/reference/get_call.html","id":null,"dir":"Reference","previous_headings":"","what":"Get information about currently executing calls. — get_call","title":"Get information about currently executing calls. — get_call","text":"get_call(env), given environment associated currently executing call, returns function call arguments, dots object. replicate call, dots object returned can passed . get_function(env) finds function object associated currently executing call.","code":""},{"path":"/reference/get_call.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get information about currently executing calls. — get_call","text":"","code":"get_call(   env = caller(environment()),   ifnotfound = stop(\"get_call: environment not found on stack\") )  get_function(   env = caller(environment()),   ifnotfound = stop(\"get_function: environment not found on stack\") )"},{"path":"/reference/get_call.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get information about currently executing calls. — get_call","text":"env environment belonging currently executing function call. default, caller get_call (get_call() equivalent get_call(environment()).) ifnotfound return call found. default error thrown.","code":""},{"path":"/reference/get_call.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get information about currently executing calls. — get_call","text":"get_call returns dots object, first element represents function name caller environment. get_function returns closure.","code":""},{"path":"/reference/get_call.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get information about currently executing calls. — get_call","text":"get_call meant replace match.call sys.call; advantage captures environments bound arguments addition written form. get_function similar sys.function, keyed environment rather number.","code":""},{"path":[]},{"path":"/reference/get_call.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get information about currently executing calls. — get_call","text":"","code":"# We might think of re-writing the start of [lm] like so: LM <- function(formula, data, subset, weights, na.action, method = \"qr\",                model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE,                 contrasts = NULL, offset, ...) {   cl <- get_call()   mf <- do(model.frame,            arg_list(formula, data, subset, weights, na.action, offset))    z <- get.call()    class(z) <- c(\"LM\", class(z))   z$call <- cl   z }  # and `update` like so: update.LM <- function(object, formula., ...) {   call <- object$call   extras <- dots(...)   call$formula <- forced_quo(update.formula(formula(object), formula.))   do(call) }"},{"path":"/reference/get_dots.html","id":null,"dir":"Reference","previous_headings":"","what":"Set or get the contents of .... — get_dots","title":"Set or get the contents of .... — get_dots","text":"get_dots() unpacks ... given environment returns dots object. set_dots takes dots list uses create binding ... given environment.","code":""},{"path":"/reference/get_dots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set or get the contents of .... — get_dots","text":"","code":"get_dots(env = caller(environment()), inherits = FALSE)  set_dots(env, d, append = FALSE)"},{"path":"/reference/get_dots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set or get the contents of .... — get_dots","text":"env environment look . inherits Whether pull ... enclosing environments. d [dots] object. append TRUE, values appended existing binding. false, existing binding \"...\" replaced.","code":""},{"path":"/reference/get_dots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set or get the contents of .... — get_dots","text":"get_dots returns dots list. ... bound missing, returns empty dots list. set_dots returns updated environment, invisibly.","code":""},{"path":"/reference/get_dots.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Set or get the contents of .... — get_dots","text":"get_dots() equivalent dots(...) arg_list(`...`).","code":""},{"path":[]},{"path":"/reference/locate.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the environment which defines a name. — locate","title":"Find the environment which defines a name. — locate","text":"locate starts given environment, searches enclosing environments name. returns first enclosing environment defines sym. locate_ normally evaluating method; locate(x) equivalent locate_(quo(x)) locate_(quote(x), environment()). sym quotation dots, env argument ignored.","code":""},{"path":"/reference/locate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the environment which defines a name. — locate","text":"","code":"locate(sym, env = arg_env_(quote(sym), environment()), mode = \"any\", ...)  locate_(sym, env = arg_env_(quote(sym), environment()), mode = \"any\", ...)  locate_.list(sym, env = arg_env_(quote(sym), environment()), mode = \"any\", ...)  locate_.quotation(sym, env = \"ignored\", mode = \"any\", ...)  locate_.character(   sym,   env = arg_env_(quote(sym), environment()),   mode = \"any\",   ... )  `locate_.(`(sym, env = arg_env_(quote(sym), environment()), mode = \"any\", ...)  locate_.dots(sym, env = \"ignored\", mode = \"any\", ...)  locate_.name(   sym,   env = arg_env_(quote(sym), environment()),   mode = \"any\",   ifnotfound = stop(\"Binding \", deparse(sym), \" not found\") )"},{"path":"/reference/locate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the environment which defines a name. — locate","text":"sym name. locate argument used literally. locate_ name list names. env environment begin searching . mode Either \"\" \"function\". \"\" finds lowest enclosing environment gives definiton sym. \"function\" searches environment defines sym function. may force lazy arguments process, way get. ... arguments passed methods. ifnotfound returned symbol found. default exception raised.","code":""},{"path":"/reference/locate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the environment which defines a name. — locate","text":"environment object defines sym, one found. sym list (names) dots object, locate_(sym)returns list.","code":""},{"path":"/reference/locate.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Find the environment which defines a name. — locate","text":"locate ... bound, can wrap parens, locate( (...) ). use literal character argument, locate(\"x\", environment()), must also provide environment argument explicitly; locate(\"x\") work compiled functions. However using literal name like locate(x) work OK. See note arg.","code":""},{"path":"/reference/locate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find the environment which defines a name. — locate","text":"","code":"# Here is how to implement R's `<<-` operator, using `locate_`: `%<<-%` <- function(lval, rval) {   lval_ <- arg(lval)   name <- expr(lval_)   target.env <- locate_(name, parent.env(env(lval_)))   assign(as.character(name), rval, envir=target.env) }  x <- \"not this one\" local({   x <- \"this one\"   local({     x <- \"not this one either\"     x %<<-% \"this works like builtin <<-\"   })   print(x) }) #> [1] \"this works like builtin <<-\" print(x) #> [1] \"not this one\""},{"path":"/reference/missing_value.html","id":null,"dir":"Reference","previous_headings":"","what":"R's missing value. — missing_value","title":"R's missing value. — missing_value","text":"missing_value() returns R's missing object; R uses represent missing argument. distinct either NULL NA.","code":""},{"path":"/reference/missing_value.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"R's missing value. — missing_value","text":"","code":"missing_value(n)  missing_(x, unwrap = TRUE)  # S3 method for default missing_(x, unwrap = TRUE)  # S3 method for dots missing_(x, unwrap = TRUE)  # S3 method for quotation missing_(x, unwrap = TRUE)  list_missing(...)"},{"path":"/reference/missing_value.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"R's missing value. — missing_value","text":"n Optional; number. provided, return list missing values many elements. x value, dots, list. unwrap Whether descend recursively unevaluated promises using unwrap(x, TRUE) ... Arguments evaluated normally. except missing.","code":""},{"path":"/reference/missing_value.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"R's missing value. — missing_value","text":"missing_value returns symbol empty name, list . missing_ returns logical vector. list_missing returns list.","code":""},{"path":"/reference/missing_value.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"R's missing value. — missing_value","text":"missing value occurs naturally quoted R expression empty argument: can use missing_value() help construct expressions: expression evaluated starts function call, missing value winds promise expression. \"normal evaluation\", finding missing value variable raises error. means sometimes tricky work missings: Generally, keep missing values wrapped lists quotations, instead assigning variables directly.","code":"exp <- quote( x[1, ] )   identical(exp[[4]], missing_value()) #TRUE   is_missing(exp[[4]]) #also TRUE substitute(f[x, y], list(x = 1, y=missing_value())) f <- function(x) arg_expr(x)   identical(f(), missing_value()) # TRUE m <- missing_value()   list(m) # raises error exp <- quote( x[1, ] )   cols <- x[[4]]   x <- list(missing_value(), 2, 3)     # this is ok, but...   a <- missing_value(); b <- 2; c <- 3 # this stores missing in \"cols\",   x <- list(a, b, c)                   # throws an error: \"a\" missing"},{"path":[]},{"path":"/reference/missing_value.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"R's missing value. — missing_value","text":"","code":"# These expressions are equivalent: function(x, y=1) {x+y} #> function(x, y=1) {x+y} #> <environment: 0x555e75b25ee8> function_(list(x=missing_value, y=1),           quote( {x+y} )) #> Warning: Argument `args` already forced so cannot determine environment. #> function (x = function (n)  #> { #>     if (missing(n)) { #>         quote(expr = ) #>     } #>     else { #>         rep(list(quote(expr = )), n) #>     } #> }, y = 1)  #> { #>     x + y #> } #> <environment: R_EmptyEnv>  # These expressions are also equivalent: quote(df[,1]) #> df[, 1] substitute(df[row,col],            list(row = missing_value(), col = 1)) #> df[, 1] # How to do the trick of `[` where it can tell which arguments are # missing: `[.myclass` <- function(x, ...) {    indices <- list_missing(...)    kept.axes <- which(missing_(indices))    cat(paste0(\"Keeping axes \", kept_axes, \"\\n\"))    #... } ar <- structure(array(1:24, c(2, 3, 4))) ar[, 3, ] #>      [,1] [,2] [,3] [,4] #> [1,]    5   11   17   23 #> [2,]    6   12   18   24"},{"path":"/reference/quo.html","id":null,"dir":"Reference","previous_headings":"","what":"Quotation objects. — quo","title":"Quotation objects. — quo","text":"quo(expr, env) captures expr without evaluating, returns qutation object. quotation two parts: expression expr(q) environment env(q). quo_(expr, env) normally evaluating version. constructs quotation given expression environment. .quo(x) converts object quotation. Closures, formulas, single-element dots can converted way. forced_quo(x) captures expression argument, forces , returning quotation expression value. forced_quo_(val) makes forced quotation given value. Specifically constructs quotation object expr value slots, except language object case expr slot wrapped quote().","code":""},{"path":"/reference/quo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quotation objects. — quo","text":"","code":"quo(expr, env = arg_env_(quote(expr), environment()), force = FALSE)  quo_(expr, env, force = FALSE)  env(q)  env(q) <- value  expr(q)  # S3 method for quotation expr(q)  expr(q) <- value  is.quotation(x)  is.quo(x)  as.quo(x)  forced_quo(x)  forced_quo_(val)"},{"path":"/reference/quo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quotation objects. — quo","text":"expr expression. quo taken literally evaluated. quo_ evaluated normally. env environment. force Whether evaluate expression create forced quotation. q quotation object. value updated value. x object. val value.","code":""},{"path":"/reference/quo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quotation objects. — quo","text":"quo_ quo return object class \"quotation\". .quo returns quotation.","code":""},{"path":"/reference/quo.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Quotation objects. — quo","text":"(Like writing, 'expression' may simply set words, 'quotation' comes bundled citation, reference context said.) quo parallel 'promise' data structure R uses hold lazily evaluated arguments. quo different promise immutable data object. data object, quo automatically evaluate like promise, can evaluated explicitly methods value force_.  quo immutable, mutate \"forced\" state choose evaluate ; instead force_(q) returns new object forced state. function can capture arguments quotations using arg. dots object list quotations.","code":""},{"path":"/reference/set_.html","id":null,"dir":"Reference","previous_headings":"","what":"Assign values to variables — set_","title":"Assign values to variables — set_","text":"set_ normally-evaluating version <-. set_enclos_ normally evaluating version <<-.","code":""},{"path":"/reference/set_.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assign values to variables — set_","text":"","code":"set_(dest, val)  set_enclos_(dest, val)"},{"path":"/reference/set_.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assign values to variables — set_","text":"dest quotation specifying destination environment name. val value assign.","code":""},{"path":"/reference/set_.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assign values to variables — set_","text":"set_ returns val, invisibly.","code":""},{"path":"/reference/set_.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Assign values to variables — set_","text":"set_ differs [assign] set_ process subassignments. helpers tricky use do_ <- (see Note do_).","code":""},{"path":"/reference/set_.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assign values to variables — set_","text":"","code":"set_(quo(x), 12) #equivalent to `x <- 12` set_(quo(x[3]), 12) #equivalent to `x[3] <- 12` e <- new.env() set_(quo(x[3], e), 12) #assigns in environment `e` set_enclos_(quo(x[3], e), 12) #assigns in a parent of environment `e`"},{"path":"/reference/shortcut.html","id":null,"dir":"Reference","previous_headings":"","what":"Get information about currently bound arguments. — arg_env","title":"Get information about currently bound arguments. — arg_env","text":"shortcut methods querying current bindings.  example, arg_env(x) equivalent env(arg(x)), is_forced(x, y) equivalent forced(arg_list(x,y)), dots_exprs(...) equivalent exprs(dots(...)), . shortcut forms skip construction intermediate quotation objects. dots_exprs(...) quotes arguments returns list expressions. equivalent exprs(dots(...)) (nearly equivalent alist(...), one difference dots_exprs expand ....) is_literal(x) returns TRUE argument x source literal. Specifically tests whether x bound singleton vector missing_value. check happens without forcing x. is_missing(...) checks whether argument missing, without forcing. similar missing can take multiple arguments, can called situations, nested inner function. is_missing_(syms, envs) normally evaluating version is_missing.  syms symbol, character vector list . envs environment, list environments. Vector recycling rules apply, can call vector names one env, vice versa. is_promise returns TRUE given variable bound promise. arguments bound promises; byte-compiled code often omits creating promise literal missing arguments. is_default  determines whether argument bound function's default value argument. must called arguments forced (afterwards return FALSE).","code":""},{"path":"/reference/shortcut.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get information about currently bound arguments. — arg_env","text":"","code":"arg_env(sym, env = arg_env_(quote(sym), environment()))  arg_env_(sym, env = arg_env_(quote(sym), environment()))  arg_expr(sym, env = arg_env_(quote(sym), environment()))  arg_expr_(sym, env = arg_env_(quote(sym), environment()))  dots_envs(...)  dots_exprs(...)  is_forced(...)  is_forced_(syms, envs)  is_literal(...)  is_literal_(syms, envs)  is_missing(...)  is_missing_(syms, envs, unwrap = TRUE)  # S3 method for quotation is_missing_(syms, ..., unwrap = TRUE)  is_promise(...)  is_promise_(syms, envs)  # S3 method for quotation is_promise_(syms, ...)  is_default(...)  is_default_(syms, envs)  # S3 method for quotation is_default_(syms, ...)"},{"path":"/reference/shortcut.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get information about currently bound arguments. — arg_env","text":"sym plain arg_env, etc, bare name, quoted. underscore versions arg_env_, something evaluates name character. env environment search . ... Bare variable names (is_*) expressions (dots_*). forced. syms character vector list symbols. envs environment list environments. unwrap Whether recursively unwrap testing missingness.","code":""},{"path":"/reference/shortcut.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get information about currently bound arguments. — arg_env","text":"arg_env returns environment. arg_expr returns expression bound named argument. is_forced is_* return logical vector optional names.","code":""},{"path":"/reference/shortcut.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get information about currently bound arguments. — arg_env","text":"Throughout package, functions come two forms, \"bare\" version quote first argument literally, normally-evaluating version trailing underscore name. is_forced(x) chiecks whether \"x\" missing variable, is_forced_(x, environment()) checks whether \"x\" contains name another variable missing. following equivalent: arg_env(x) {y <- quo(x); arg_env_(y)} arg_env_(quote(x), environment()) arg_env_(quo(x)) env(arg_(quo(x))). used quotation objects, is_*_ functions trailing underscore work one level indirection compared quotation methods. example, missing_(x) tests whether expr(x) [missing_value()], whereas is_missing_(x) assumes expr(x) name checks name refers variable missing. following equivalent: is_missing(x) is_missing_(quo(x)) missing_(arg(x)) used quotation dots, is_missing(q) looks variable(s) specified expr(q) environment env(q)]`.","code":""},{"path":"/reference/unwrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Unwrap variable references. — unwrap","title":"Unwrap variable references. — unwrap","text":"Given unforced quotation whose expression bare variable name, unwrap follows variable reference, returns quotation. argument forced nontrivial expression unwrap effect.","code":""},{"path":"/reference/unwrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unwrap variable references. — unwrap","text":"","code":"unwrap(x, recursive = FALSE)  # S3 method for dots unwrap(x, recursive = FALSE)"},{"path":"/reference/unwrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unwrap variable references. — unwrap","text":"x quotation unwrap. recursive Default FALSE unwraps exactly . TRUE, unwrap far possible (forced promise nontrivial expression found.)","code":""},{"path":"/reference/unwrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unwrap variable references. — unwrap","text":"quotation method returns quotation. dots method returns dots object quotation unwrapped.","code":""},{"path":"/reference/unwrap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Unwrap variable references. — unwrap","text":"two good use cases unwrap(x, recursive=TRUE). One derive plot labels (inoccuous use metaprogramming). Another check missingness (R's missing well). Using unwrap(x, recursive=TRUE) situations can get confusing situations -- effectively changing behavior parent function may unknown number levels stack, possibly turning standard-evaluating function nonstandard-evaluating function. recursive unerapping default behavior.","code":""},{"path":"/reference/unwrap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unwrap variable references. — unwrap","text":"","code":"# different levels of unwrapping: f <- function(x) { g(x) } g <- function(y) { h(y) } h <- function(z) {   print(arg(z))   print(unwrap(quo(z)))   print(unwrap(unwrap(quo(z))))   print(unwrap(quo(z), recursive=TRUE)) }  w <- 5 f(w) #> quo(y, <environment: 0x555e74fe95a8>)  #> quo(y, <environment: 0x555e74fe95a8>)  #> quo(x, <environment: 0x555e74fe9490>)  #> quo(w, <environment: 0x555e75f8b7a0>)"},{"path":"/news/index.html","id":"nseval-042","dir":"Changelog","previous_headings":"","what":"nseval 0.4.2","title":"nseval 0.4.2","text":"Fixes: * Fixed handling missing arguments quo * now passes arguments via temporary binding ... cases. fix cases sys.calls() returned naked promises, made confusing debugging. * Fixed man pages generated completely. Changes: * Implemented .equal method quotation objects. * dots quotation objects now print deparse()-like style. * is_*_() functions methods promises/dots. * set_ set_enclos_ added help making assignments.","code":""},{"path":"/news/index.html","id":"nseval-041","dir":"Changelog","previous_headings":"","what":"nseval 0.4.1","title":"nseval 0.4.1","text":"Fixes: * caller now correctly returns ifnotfound argument.","code":""},{"path":"/news/index.html","id":"nseval-04","dir":"Changelog","previous_headings":"","what":"nseval 0.4","title":"nseval 0.4","text":"CRAN release: 2018-08-06 Initial CRAN Release.","code":""}]
